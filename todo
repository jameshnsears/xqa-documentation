= record results in a .xls
= put results, in graph form, in performance.md

==================

in shard - how to show how many concurrent connections are active?

==================

tidy up github notes & merge the todo notes in here

==================

2017-12-28 17:07:53.913     ERROR --- [    InserterThread-5]:                       run,  46: Transport closed due to the peer exceeding our requested idle-timeout
javax.jms.JMSException: Transport closed due to the peer exceeding our requested idle-timeout
    at org.apache.qpid.jms.exceptions.JmsExceptionSupport.create(JmsExceptionSupport.java:86)
    at org.apache.qpid.jms.exceptions.JmsExceptionSupport.create(JmsExceptionSupport.java:108)
2017-12-28 17:07:53.914     ERROR --- [    InserterThread-2]:                       run,  46: Transport closed due to the peer exceeding our requested idle-timeout
    at org.apache.qpid.jms.JmsConnection.send(JmsConnection.java:692)
    at org.apache.qpid.jms.JmsConnection.send(JmsConnection.java:676)
    at org.apache.qpid.jms.JmsNoTxTransactionContext.send(JmsNoTxTransactionContext.java:36)
    at org.apache.qpid.jms.JmsSession.send(JmsSession.java:879)
    at org.apache.qpid.jms.JmsSession.send(JmsSession.java:770)
    at org.apache.qpid.jms.JmsMessageProducer.sendMessage(JmsMessageProducer.java:246)
    at org.apache.qpid.jms.JmsMessageProducer.send(JmsMessageProducer.java:176)
    at xqa.commons.MessageSender.sendMessage(MessageSender.java:54)
    at xqa.InserterThread.insert(InserterThread.java:151)
    at xqa.InserterThread.run(InserterThread.java:43)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.io.IOException: Transport closed due to the peer exceeding our requested idle-timeout
    at org.apache.qpid.jms.provider.amqp.AmqpProvider$IdleTimeoutCheck.run(AmqpProvider.java:1432)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    ... 3 more
javax.jms.JMSException: Transport closed due to the peer exceeding our requested idle-timeout
    at org.apache.qpid.jms.exceptions.JmsExceptionSupport.create(JmsExceptionSupport.java:86)
    at org.apache.qpid.jms.exceptions.JmsExceptionSupport.create(JmsExceptionSupport.java:108)
    at org.apache.qpid.jms.JmsConnection.send(JmsConnection.java:692)
    at org.apache.qpid.jms.JmsConnection.send(JmsConnection.java:676)
    at org.apache.qpid.jms.JmsNoTxTransactionContext.send(JmsNoTxTransactionContext.java:36)
    at org.apache.qpid.jms.JmsSession.send(JmsSession.java:879)
    at org.apache.qpid.jms.JmsSession.send(JmsSession.java:770)
    at org.apache.qpid.jms.JmsMessageProducer.sendMessage(JmsMessageProducer.java:246)
    at org.apache.qpid.jms.JmsMessageProducer.send(JmsMessageProducer.java:176)
    at xqa.commons.MessageSender.sendMessage(MessageSender.java:54)
    at xqa.InserterThread.insert(InserterThread.java:151)
    at xqa.InserterThread.run(InserterThread.java:43)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.io.IOException: Transport closed due to the peer exceeding our requested idle-timeout
    at org.apache.qpid.jms.provider.amqp.AmqpProvider$IdleTimeoutCheck.run(AmqpProvider.java:1432)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    ... 3 more

==================

= use the subject to hold the ingest filename
    = on xqa-ing* use the subject branch
        = see: http://activemq.apache.org/amqp.html

==================

PN_TRACE_EVT=1 PN_TRACE_FRM=1 python receiver.py

==================

take off an ingest msg in a transactional...
tx.start
= take off message
= find smallest shard
= send to smallest shard
= tx.commit

if no shards reply then tx.rollback, wait a little an try n times more before shutting down

==================

have it so that tags in github are all alphabetical + similar

==================

pycodestyle - in pip - use it!

===================

-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=<PORT_NUMBER> -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=<HOST'S_IP>
service:jmx:rmi:///jndi/rmi://<HOST'S_IP>:<PORT_NUMBER>/jmxrmi

==================

. use angular 2 on ui component

. create a video of using the app?

. test/e2e/
. test/integration/
. test/unit
. test/perf - 100 xml files?

. produce performance metrics for XQA v. normal BaseX (file); BaseX RAM.

. bdd
= behave v. lettuce - these are supported in pycharm

. in xqa-document/README mention sharding and materialised views: see Microsoft cloud patterns

. create example deployment topography diagrams

. bold cassandra onto everything for unit test asserts
